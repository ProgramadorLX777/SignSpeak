import cv2
import mediapipe as mp
import numpy as np
import joblib
import time

modelo = joblib.load("models/modelo_senas.pkl")

mp_hands = mp.solutions.hands
hands = mp_hands.Hands(static_image_mode=False, max_num_hands=2, min_detection_confidence=0.7)
mp_draw = mp.solutions.drawing_utils

cap = cv2.VideoCapture(0)

print("游니 Reconociendo se침as... (ESC para salir)")

prev_landmarks = None
stabilized_time = 0
threshold_stable = 1.0  # segundos sin moverse
movement_threshold = 0.02
letra_prev = ""
letra_final = ""

while True:
    ret, frame = cap.read()
    if not ret:
        break

    frame = cv2.flip(frame, 1)
    rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    results = hands.process(rgb)

    texto = "No detectado"

    if results.multi_hand_landmarks:
        datos = []
        current_landmarks = []

        for hand in results.multi_hand_landmarks:
            for lm in hand.landmark:
                datos.extend([lm.x, lm.y])
                current_landmarks.append((lm.x, lm.y))

        # Completar datos si hay menos puntos
        while len(datos) < 84:
            datos.append(0.0)

        if len(datos) == 84:
            prediccion = modelo.predict([datos])[0]

            # Comprobaci칩n especial para I vs J
            if prediccion == "I":
                if prev_landmarks:
                    # Calcular movimiento promedio
                    diffs = [np.linalg.norm(np.array(c) - np.array(p)) for c, p in zip(current_landmarks, prev_landmarks)]
                    movimiento = sum(diffs) / len(diffs)

                    if movimiento < movement_threshold:
                        # Si no se mueve, iniciar temporizador
                        if stabilized_time == 0:
                            stabilized_time = time.time()
                        elif time.time() - stabilized_time >= threshold_stable:
                            letra_final = "I"
                    else:
                        if stabilized_time != 0 and time.time() - stabilized_time >= threshold_stable:
                            letra_final = "J"
                        stabilized_time = 0
                else:
                    stabilized_time = 0
                prev_landmarks = current_landmarks
            else:
                letra_final = prediccion
                stabilized_time = 0
                prev_landmarks = None

            texto = letra_final

        for handLms in results.multi_hand_landmarks:
            mp_draw.draw_landmarks(frame, handLms, mp_hands.HAND_CONNECTIONS)

    else:
        texto = "No detectado"
        stabilized_time = 0
        prev_landmarks = None

    # Contorno negro (m치s grueso)
    cv2.putText(frame, f"Sena: {texto}", (10, 40),
            cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 0, 0), 6, cv2.LINE_AA)

    # Texto blanco encima (m치s fino)
    cv2.putText(frame, f"Sena: {texto}", (10, 40),
            cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255, 255, 255), 2, cv2.LINE_AA)


    '''cv2.putText(frame, f"Sena: {texto}", (10, 40),
                cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 3)'''

    cv2.imshow("Reconocimiento - Presione ESC para Salir", frame)

    if cv2.waitKey(1) & 0xFF == 27:  # ESC
        break

cap.release()
cv2.destroyAllWindows()
